* COPYRIGHT (c) 1987 AEA Technology
* Original date 10 Feb 1993
C       Toolpack tool decs employed.
C 20/2/02 Cosmetic changes applied to reduce single/double differences

C 12th July 2004 Version 1.0.0. Version numbering added.

      SUBROUTINE MC34AD(N,IRN,JCOLST,YESA,A,IW)
C THIS SUBROUTINE ACCEPTS AS INPUT THE STANDARD DATA STRUCTURE FOR
C     A SYMMETRIC MATRIX STORED AS A LOWER TRIANGLE AND PRODUCES
C     AS OUTPUT THE SYMMETRIC MATRIX HELD IN THE SAME DATA
C     STRUCTURE AS A GENERAL MATRIX.
C N IS AN INTEGER VARIABLE THAT MUST BE SET BY THE USER TO THE
C     ORDER OF THE MATRIX. NOT ALTERED BY THE ROUTINE
C     RESTRICTION (IBM VERSION ONLY): N LE 32767.
C IRN IS AN INTEGER (INTEGER*2 IN IBM VERSION) ARRAY THAT
C     MUST BE SET BY THE USER TO HOLD THE ROW INDICES OF THE LOWER
C     TRIANGULAR PART OF THE SYMMETRIC MATRIX.  THE ENTRIES OF A
C     SINGLE COLUMN ARE CONTIGUOUS. THE ENTRIES OF COLUMN J
C     PRECEDE THOSE OF COLUMN J+1 (J_=_1, ..., N-1), AND THERE IS
C     NO WASTED SPACE BETWEEN COLUMNS. ROW INDICES WITHIN A COLUMN
C     MAY BE IN ANY ORDER.  ON EXIT IT WILL HAVE THE SAME MEANING
C     BUT WILL BE CHANGED TO HOLD THE ROW INDICES OF ENTRIES IN
C     THE EXPANDED STRUCTURE.  DIAGONAL ENTRIES NEED NOT BE
C     PRESENT. THE NEW ROW INDICES ADDED IN THE UPPER TRIANGULAR
C     PART WILL BE IN ORDER FOR EACH COLUMN AND WILL PRECEDE THE
C     ROW INDICES FOR THE LOWER TRIANGULAR PART WHICH WILL REMAIN
C     IN THE INPUT ORDER.
C JCOLST IS AN INTEGER ARRAY OF LENGTH N+1 THAT MUST BE SET BY
C     THE USER SO THAT JCOLST(J) IS THE POSITION IN ARRAYS IRN AND
C     A OF THE FIRST ENTRY IN COLUMN J (J_=_1, ..., N).
C     JCOLST(N+1) MUST BE SET TO ONE MORE THAN THE TOTAL NUMBER OF
C     ENTRIES.  ON EXIT, JCOLST(J) WILL HAVE THE SAME MEANING BUT
C     WILL BE CHANGED TO POINT TO THE POSITION OF THE FIRST ENTRY
C     OF COLUMN J IN THE EXPANDED STRUCTURE. THE NEW VALUE OF
C     JCOLST(N+1) WILL BE ONE GREATER THAN THE NUMBER OF ENTRIES
C     IN THE EXPANDED STRUCTURE.
C YESA IS A LOGICAL VARIABLE THAT MUST BE SET TO .TRUE. IF THE
C     USER DESIRES TO GENERATE THE EXPANDED FORM FOR THE VALUES ALSO.
C     IF YESA IS .FALSE., THE ARRAY A WILL NOT BE REFERENCED.  IT IS
C     NOT ALTERED BY THE ROUTINE.
C A IS A REAL (DOUBLE PRECISION IN THE D VERSION) ARRAY THAT
C     CAN BE SET BY THE USER SO THAT A(K) HOLDS THE VALUE OF THE
C     ENTRY IN POSITION K OF IRN, {K = 1, _..._ JCOLST(N+1)-1}.
C     ON EXIT, IF YESA IS .TRUE., THE ARRAY WILL HOLD THE VALUES
C     OF THE ENTRIES IN THE EXPANDED STRUCTURE CORRESPONDING TO
C     THE OUTPUT VALUES OF IRN.   IF YESA IS .FALSE., THE ARRAY IS
C     NOT ACCESSED BY THE SUBROUTINE.
C IW IS AN INTEGER (INTEGER*2 IN IBM VERSION) ARRAY OF LENGTH
C     N THAT WILL BE USED AS WORKSPACE.
C
C CKP1 IS A LOCAL VARIABLE USED AS A RUNNING POINTER.
C OLDTAU IS NUMBER OF ENTRIES IN SYMMETRIC STORAGE.
C     .. Scalar Arguments ..
      INTEGER N
      LOGICAL YESA
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(*)
      INTEGER IRN(*),IW(*),JCOLST(*)
C     ..
C     .. Local Scalars ..
      INTEGER CKP1,I,I1,I2,II,IPKP1,IPOS,J,JSTART,LENK,NDIAG,NEWTAU,
     +        OLDTAU
C     ..
C     .. Executable Statements ..
C
      OLDTAU = JCOLST(N+1) - 1
C INITIALIZE WORK ARRAY
      DO 5 I = 1,N
        IW(I) = 0
    5 CONTINUE
C
C IW(J) IS SET EQUAL TO THE TOTAL NUMBER OF ENTRIES IN COLUMN J
C     OF THE EXPANDED SYMMETRIC MATRIX.
C NDIAG COUNTS NUMBER OF DIAGONAL ENTRIES PRESENT
      NDIAG = 0
      DO 20 J = 1,N
        I1 = JCOLST(J)
        I2 = JCOLST(J+1) - 1
        IW(J) = IW(J) + I2 - I1 + 1
        DO 10 II = I1,I2
          I = IRN(II)
          IF (I.NE.J) THEN
            IW(I) = IW(I) + 1

          ELSE
            NDIAG = NDIAG + 1
          END IF

   10   CONTINUE
   20 CONTINUE
C
C NEWTAU IS NUMBER OF ENTRIES IN EXPANDED STORAGE.
      NEWTAU = 2*OLDTAU - NDIAG
C IPKP1 POINTS TO POSITION AFTER END OF COLUMN BEING CURRENTLY
C     PROCESSED
      IPKP1 = OLDTAU + 1
C CKP1 POINTS TO POSITION AFTER END OF SAME COLUMN IN EXPANDED
C     STRUCTURE
      CKP1 = NEWTAU + 1
C GO THROUGH THE ARRAY IN THE REVERSE ORDER PLACING LOWER TRIANGULAR
C     ELEMENTS IN THE APPROPRIATE SLOTS.
      DO 40 J = N,1,-1
        I1 = JCOLST(J)
        I2 = IPKP1
C LENK IS NUMBER OF ENTRIES IN COLUMN J OF ORIGINAL STRUCTURE
        LENK = I2 - I1
C JSTART IS RUNNING POINTER TO POSITION IN NEW STRUCTURE
        JSTART = CKP1
C SET IKP1 FOR NEXT COLUMN
        IPKP1 = I1
        I2 = I2 - 1
C RUN THROUGH COLUMNS IN REVERSE ORDER
C LOWER TRIANGULAR PART OF COLUMN MOVED TO END OF SAME COLUMN IN
C     EXPANDED FORM
        DO 30 II = I2,I1,-1
          JSTART = JSTART - 1
          IF (YESA) A(JSTART) = A(II)
          IRN(JSTART) = IRN(II)
   30   CONTINUE
C JCOLST IS SET TO POSITION OF FIRST ENTRY IN LOWER TRIANGULAR PART OF
C     COLUMN J IN EXPANDED FORM
        JCOLST(J) = JSTART
C SET CKP1 FOR NEXT COLUMN
        CKP1 = CKP1 - IW(J)
C RESET IW(J) TO NUMBER OF ENTRIES IN LOWER TRIANGLE OF COLUMN.
        IW(J) = LENK
   40 CONTINUE
C
C AGAIN SWEEP THROUGH THE COLUMNS IN THE REVERSE ORDER, THIS
C     TIME WHEN ONE IS HANDLING COLUMN J THE UPPER TRIANGULAR
C     ELEMENTS A(J,I) ARE PUT IN POSITION.
      DO 80 J = N,1,-1
        I1 = JCOLST(J)
        I2 = JCOLST(J) + IW(J) - 1
C RUN DOWN COLUMN IN ORDER
C NOTE THAT I IS ALWAYS GREATER THAN OR EQUAL TO J
        DO 60 II = I1,I2
          I = IRN(II)
          IF (I.EQ.J) GO TO 60
          JCOLST(I) = JCOLST(I) - 1
          IPOS = JCOLST(I)
          IF (YESA) A(IPOS) = A(II)
          IRN(IPOS) = J
   60   CONTINUE
   80 CONTINUE
      JCOLST(N+1) = NEWTAU + 1
      RETURN

      END
