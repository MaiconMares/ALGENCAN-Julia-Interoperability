C COPYRIGHT (c) 1995 Timothy A. Davis, Patrick Amestoy and
C           Council for the Central Laboratory of the Research Councils
C Original date 30 November 1995
C  April 2001: call to MC49 changed to MC59 to make routine threadsafe
C 20/2/02 Cosmetic changes applied to reduce single/double differences

C 12th July 2004 Version 1.0.0. Version numbering added.
C 23 May 2007 Version 1.1.0. Absolute value of hash taken to cover the
C            case of integer overflow.
C            Comments with character in column 2 corrected.
C 2 August 2007 Version 2.0.0 Dense row handling added, error & warning
C            messages added, iovflo added, interface changed. MC47I/ID
C            added.
C 31 October 2007 Version 2.1.0 Corrected tree formation when handling
C            full variables
C

      SUBROUTINE MC47ID(ICNTL)
      INTEGER ICNTL(10)
C ICNTL is an INTEGER array of length 10 that contains control
C     parameters and must be set by the user. Default values are set
C     by MA57ID.
C
C     ICNTL(1) is the stream number for error messages. Printing is
C     suppressed if ICNTL(1)<0. The default is 6.
C
C     ICNTL(2) is the stream number for warning messages. Printing is
C     suppressed if ICNTL(2)<0. The default is 6.
C
C     ICNTL(3) is the stream number for printing matrix data on entry
C     to and exit from MC47A/AD. Printing is suppressed if ICNTL(3)<0.
C     The default is -1.
C
C     ICNTL(4) controls the choice of AMD algorithm
C   =-1 Classical MC47B (AMD) algorithm (no dense row detection)
C   = 0 Only exactly dense rows in the reduced matrix are selected.
C   = 1 Corresponds to automatic setting of the minimum density
C     requirement.
C     The default value is 1.
C
C     ICNTL(5) defines the largest positive
C     integer that your computer can represent (-iovflo should also
C     be representable). HUGE(1) in Fortran 95. The default value is
C     2139062143
C
C     ICNTL(6) to ICNTL(10) are set to zero by MA57ID but are not
C     currently used by MC47.
C
C Local variables
      INTEGER I

      ICNTL(1) = 6
      ICNTL(2) = 6
      ICNTL(3) = -1
      ICNTL(4) = 1
      ICNTL(5) = 2139062143

      DO 100 I=6,10
        ICNTL(I) = 0
 100  CONTINUE
      RETURN
      END


      SUBROUTINE MC47AD(N, NE, PE, IW, IWLEN,
     *      ICNTL,INFO, RINFO)
      INTEGER N, NE, PE(N+1), IWLEN, IW(IWLEN), INFO(10)
      INTEGER ICNTL(10)
      DOUBLE PRECISION RINFO(10)
C N is an INTEGER variable that must be set by the user to the
C     order of the matrix A.  It is not altered by the subroutine.
C     Restriction: N >= 1.
C NE is an INTEGER variable that must be set by the user to the
C     number of entries in the matrix A.
C     It is not altered by the subroutine.
C PE is an INTEGER  array of size N+1 that must be set by the user.
C     If the user is supplying the entries by columns, then PE(i) must
C     hold the index in IW of the start of column i, i=1, ..., N and
C     PE(N+1) must be equal to NE+1.  If the user is supplying row and
C     column indices for the matrix, PE(1) must be negative.
C     On exit, PE will hold information on the matrix factors.
C IW is an INTEGER  array of length IWLEN that must be set by the user
C     to hold the pattern of the matrix A.  If PE(1) is positive,
C     IW(PE(J)), ..., IW(PE(J+1)-1) must hold the row indices of entries
C     in column J, J = 1, ..., N.
C     The entries within a column need not be in order.
C     If PE(1) is negative, then (IW(k), IW(NE+k)), k = 1, ..., NE, must
C     hold the row and column index of an entry.
C     Duplicates, out-of-range entries, diagonal entries, and entries
C     in upper triangle are ignored.
C     IW is used as workspace by the subroutine.  On exit, the
C     permutation generated by MC47 is held in IW(IWLEN-I+1), I=1, ... N
C     and is such that the kth column of the permuted matrix is column
C     IW(IWLEN-N+k) of the original matrix.
C     The inverse permutation is held in positions IWLEN-2N+1 to
C     IWLEN-N of IW, preceded by further information on the structure
C     of the factors
C IWLEN is an INTEGER variable. It must be set by the user to the length
C     of array IW and is not altered by the subroutine.
C     We recommend IWLEN > 2NE + 9N.   Restriction: IWLEN >= 2NE + 8N.
C ICNTL is an INTEGER array of length 10 that contains control
C     parameters and must be set by the user. Default values for the
C     components may be set by a call to MC47ID.
C INFO is an INTEGER array of length 8 that need not be set by the user.
C     On return from MC47A/AD, a value of zero for INFO(1) indicates
C     that the subroutine has performed successfully.  Negative values
C     for INFO(1) signify a fatal error.  Possible values are:
C     -1    N < 1
C     -2    IWLEN < 2NE + 8N.
C     -3    Error in PE when input is by columns.
C     -4    Matrix is null (usually because all entries in upper
C           triangle.
C     There is one warning indicated by a positive value for INFO(1)
C     +1    Out-of-range index, duplicate, diagonal or entry in upper
C           triangle in input. Action taken is to ignore these entries.
C     The other entries of INFO give information to the user.
C     INFO(2) gives the number of compresses performed on the array IW.
C             A large value for this indicates that the ordering could
C             be found more quickly if IWLEN were increased.
C     INFO(3) gives the minimum necessary value for IWLEN for a
C             successful run of MC47A/AD on the same matrix as has just
C             been analysed, without the need for any compresses of IW.
C     INFO(4) gives the number of entries with row or column indices
C             that are out of range.  Any such entry is ignored.
C     INFO(5) gives the number of duplicate entries.  Any such entry is
C             ignored.
C     INFO(6) gives the number of entries in upper triangle.  Any such
C             entry is ignored.
C     INFO(7) gives the number of diagonal entries.  Any such entry is
C             ignored.
C     INFO(8) gives the number of restarts performed.
C RINFO is an INTEGER array of length 10 that need not be set by the
C     user. The other entries of RINFO give information to the user.
C     RINFO(1) gives forecast number of reals to hold the factorization
C     RINFO(2) gives the forecast number of flops required by the
C     factorization if no pivoting is performed.

C Local variables
      INTEGER DEGREE
      DOUBLE PRECISION DUMMY(1)
      INTEGER ELEN,HEAD,I,II,I1,I2,J,LAST,LEN,LENIW,LP,MP,
     *        NEXT,NV,PFREE,W,WP
      INTEGER ICT59(10),INFO59(10),IOUT,JOUT,IDUP,JNFO(10)
C DEGREE is used to subdivide array IW
C DUMMY  is dummy real for call to MC34A/AD
C ELEN   is used to subdivide array IW
C HEAD   is used to subdivide array IW
C I      is DO loop variable
C IFLAG  is eror return from MC59A/AD
C II     is running index for entries of IW in column
C I1     is first location for entries of IW in column
C I2     is flast location for entries of IW in column
C J      is column index and DO loop variable
C LAST   is used to subdivide array IW
C LEN    is used to subdivide array IW
C LENIW  is space left in IW after allocation of work vectors
C LP     is a local copy of ICNTL(1)
C MP     is a local copy of ICNTL(3)
C NEXT   is used to subdivide array IW
C NV     is used to subdivide array IW
C PFREE  marks active length of IW for call to MC47B/BD
C W      is used to subdivide array IW
C WP     is a local copy of ICNTL(2)
C IOUT   number of indices out-of-range
C JOUT   number of column indices out-of-range (as detected by MC59A/AD)
C IDUP   number of duplicates


C Subroutines called
      EXTERNAL MC59AD,MC34AD,MC47BD

C Initialize info
      DO 5 J = 1,10
         INFO(J) = 0
 5    CONTINUE

C Set LP,WP,MP
      LP = ICNTL(1)
      WP = ICNTL(2)
      MP = ICNTL(3)

C Check value of N
      IF (N.LT.1) THEN
        INFO(1) = -1
        IF (LP.GE.0) WRITE(LP,'(/A,I3/A,I10)')
     +       '**** Error return from MC47AD **** INFO(1) =',INFO(1),
     +       'N has value ',N
        GO TO 1000
      ENDIF

C Error check to see if enough space in IW to get started
      IF (PE(1).LT.1) THEN
        IF (2*NE+N.GT.IWLEN) THEN
          INFO(1) = -2
         IF (LP.GE.0) WRITE(LP,'(/A,I3/A,I10)')
     +        '**** Error return from MC47AD **** INFO(1) =',INFO(1),
     +        'IWLEN has value ',IWLEN
          GO TO 1000
        ENDIF
      ELSE
        IF (NE+N.GT.IWLEN) THEN
          INFO(1) = -2
         IF (LP.GE.0) WRITE(LP,'(/A,I3/A,I10)')
     +        '**** Error return from MC47AD **** INFO(1) =',INFO(1),
     +        'IWLEN has value ',IWLEN
          GO TO 1000
        ENDIF
      ENDIF

C Diagnostic print
      IF (MP.GE.0) THEN
        WRITE(MP,'(/A)') 'Entry to MC47A/AD'
        WRITE(MP,'(A,I10,A,I10,A)') 'Matrix of order',N,' with',NE,
     *                            ' entries'
        IF (PE(1).LT.0)  THEN
          WRITE(MP,'(A)') 'Matrix input in coordinate form'
          WRITE(MP,'(A/(4(I8,I8)))') 'Row and column indices',
     *          (IW(I),IW(NE+I),I=1,NE)
        ELSE
          WRITE(MP,'(A)') 'Matrix input by columns'
          DO 10 J=1,N
            WRITE(MP,'(A,I4/(10I8))') 'Column',J,
     *                                (IW(I),I=PE(J),PE(J+1)-1)
   10     CONTINUE
        ENDIF
      ENDIF

C Divide workspace
      LAST   = IWLEN  - N + 1
      ELEN   = LAST   - N
      NV     = ELEN   - N
      W      = NV     - N
      DEGREE = W      - N
      HEAD   = DEGREE - N
      NEXT   = HEAD   - N
      LEN    = NEXT   - N
      LENIW = LEN-1

C Set counters for number of upper triangular entries and diagonals
C     present in input matrix.
C These will be removed for later processing.
      INFO(6) = 0
      INFO(7) = 0

      IF (PE(1).LT.0) THEN
C First remove diagonals (if present) and all entries in upper triangle
C Note that this may give out-of-range entries from MC59.
        DO 20 I=1,NE
          IF (IW(I).LE.IW(NE+I)) THEN
            IF (IW(I).EQ.IW(NE+I) .AND. IW(I).NE.0) THEN
              INFO(7) = INFO(7) + 1
            ELSE
              IF (IW(I).GT.0) INFO(6) = INFO(6) + 1
            ENDIF
            IW(I)=0
          ENDIF
   20   CONTINUE

C Call sort routine
        ICT59(1) = 0
        ICT59(2) = 1
        ICT59(3) = 1
        ICT59(4) = LP
        ICT59(5) = -1
        ICT59(6) = 0
        CALL MC59AD(ICT59,N,N,NE,IW,NE,IW(NE+1),1,DUMMY,
     *              N+1,PE,N+1,IW(2*NE+1),INFO59)
C        IFLAG = INFO59(1)
        IDUP  = INFO59(3)
        IOUT  = INFO59(4)
        JOUT  = INFO59(5)
      ELSE

C Matrix already sorted by columns.
C Remove duplicates, out-of-range indices, and entries in upper
C       triangle.  First initialize counts.
        IDUP = 0
        IOUT = 0
        JOUT = 0

C Set array used to find duplicates
        DO 30 I = 1,N
          IW(NE+I) = 0
   30   CONTINUE

        DO 50 J=1,N
          I1 = PE(J)
          PE(J) = I1-(IOUT+IDUP)
          I2 = PE(J+1)-1
          IF (I2.LT.I1-1) THEN
            INFO(1) = -3
            GO TO 1000
          ENDIF
          DO 40 II = I1,I2
            I = IW(II)
            IF (I.LE.J .OR. I.GT.N) THEN
              IF (I.EQ.J) INFO(7) = INFO(7) + 1
              IF (I.GT.0 .AND. I.LT.J) INFO(6) = INFO(6) + 1
              IOUT = IOUT + 1
            ELSE
              IF (IW(NE+I).EQ.J) THEN
C Duplicate found
                IDUP = IDUP + 1
              ELSE
                IW(NE+I)=J
                IW(II-(IOUT+IDUP)) = I
              ENDIF
            ENDIF
   40     CONTINUE
   50   CONTINUE
        PE(N+1) = NE - (IOUT+IDUP) + 1
      ENDIF

C Set flags for duplicates or out-of-range entries
C Check if there were duplicates
      IF (IDUP.GT.0) THEN
        INFO(1) = 1
        INFO(4) = IDUP
        IF (WP.GE.0) WRITE(WP,'(/A,I3/A,I10)')
     +       '**** Warning from MC47AD **** INFO(1) =',INFO(1),
     +       'Number of duplicates found: ',INFO(4)
      ELSE
        INFO(4) = 0
      ENDIF
C Check for out of range entries
      IF (IOUT+ JOUT - INFO(7) .GT.0 ) THEN
        INFO(1) = 1
        INFO(5) = IOUT + JOUT - INFO(7)
        IF (WP.GE.0) WRITE(WP,'(/A,I3/A,I10)')
     +       '**** Warning from MC47AD **** INFO(1) =',INFO(1),
     +       'Number of out of range entries found and ignored: ',
     +       INFO(5)
      ELSE
        INFO(5) = 0
      ENDIF

C Check for entries in upper triangle
      IF (INFO(6).GT.0) THEN
         INFO(1) = 1
        IF (WP.GE.0) WRITE(WP,'(/A,I3/A,I10)')
     +       '**** Warning from MC47AD **** INFO(1) =',INFO(1),
     +       'Number of entries in upper triangle found and ignored: ',
     +        INFO(6)
      ENDIF

C Check for entries in diagonals
      IF (INFO(7).GT.0) THEN
         INFO(1) = 1
        IF (WP.GE.0) WRITE(WP,'(/A,I3/A,I10)')
     +       '**** Warning from MC47AD **** INFO(1) =',INFO(1),
     +       'Number of entries in diagonals found and ignored: ',
     +        INFO(7)
      ENDIF

C Check for null matrix
C Usually happens if wrong triangle is input
      IF (NE-(IOUT+IDUP).EQ.0) THEN
        INFO(1) = -4
        IF (LP.GE.0) WRITE(LP,'(/A,I3/A)')
     +       '**** Error return from MC47AD **** INFO(1) =',INFO(1),
     +       'Matrix is null'
        GO TO 1000
      ENDIF

C Generate matrix in expanded form
C First check there is sufficient space in IW
      IF (LENIW.LT.2*(PE(N+1)-1)) THEN
        INFO(1) = -2
         IF (LP.GE.0) WRITE(LP,'(/A,I3/A,I10/A,I10)')
     +        '**** Error return from MC47AD **** INFO(1) =',INFO(1),
     +        'IWLEN has value ',IWLEN,
     +        'Should be at least', 2*(PE(N+1)-1)+8*N
        GO TO 1000
      ENDIF

      CALL MC34AD(N,IW,PE,.FALSE.,DUMMY,IW(W))
      PFREE = PE(N+1)

C Set length array for MC47B/BD
      DO 60 I=1,N
        IW(LEN+I-1) = PE(I+1) - PE(I)
   60 CONTINUE

C Call to approximate minimum degree subroutine.
      CALL MC47BD(N,LENIW,PE,PFREE,IW(LEN),IW,IW(NV),
     *            IW(ELEN),IW(LAST),IW(DEGREE),
     *            IW(HEAD),IW(NEXT),IW(W), ICNTL,JNFO, RINFO)

      INFO(2) = JNFO(1)
      INFO(3) = PFREE+8*N
      INFO(8) = JNFO(2)

C Print diagnostics
      IF (MP.GE.0) THEN
        WRITE(MP,'(/A)') 'Exit from MC47A/AD'
        WRITE(MP,'(A/(7I10))') 'INFO(1-10):',(INFO(I),I=1,10)
        WRITE(MP,'(A/(8I10))') 'Parent array',(PE(I),I=1,N)
        WRITE(MP,'(A/(8I10))') 'Permutation',(IW(ELEN+I-1),I=1,N)
        WRITE(MP,'(A/(8I10))') 'Inverse permutation',
     *                         (IW(LAST+I-1),I=1,N)
        WRITE(MP,'(A/(8I10))') 'Degree array',(IW(NV+I-1),I=1,N)
      ENDIF

 1000 RETURN
      END

C ====================================================================
C ====================================================================
C ====================================================================

      SUBROUTINE MC47BD (N, IWLEN, PE, PFREE, LEN, IW, NV,
     $                   ELEN, LAST, DEGREE,
     $                   HEAD, DENXT, W, ICNTL, JNFO, RJNFO)

      INTEGER N, IWLEN, PE(N), PFREE, LEN(N), IW(IWLEN), NV(N),
     $        ELEN(N), LAST(N),  DEGREE(N),
     $         HEAD(N), DENXT(N), W(N), ICNTL(10), JNFO(10)

      DOUBLE PRECISION RJNFO(10)

C -------------------------------------------------------------------
C AMDD is a modified version of
C     MC47B:  Approximate Minimum (UMFPACK/MA38-style, external) Degree
C          ordering algorithm, with aggresive absorption
C designed to automatically detect and exploit dense
C rows in the reduced matrix at any step of the minimum degree.
C
C We use the term Le to denote the set of all supervariables in element
C E.
C **** Reword below***
C A row is declared as full if none of its entries can be guaranteed
C     to be zero.
C A row is quasi dense if at most N-THRESM-1 of its entries can be
C     guaranteed to be zero at it has not been recognized as being full
C     in the calculation so far.
C A row is dense if it is either full or quasi dense.
C A row is sparse if it is not dense.
C -------------------------------------------------------------------
C
C
C N must be set to the matrix order. It is not altered.
C     Restriction:  N .ge. 1
C
C IWLEN must be set to the length of IW. It is not altered. On input,
C     the matrix is stored in IW (1..PFREE-1).
C     *** We do not recommend running this algorithm with ***
C     ***      IWLEN .LT. PFREE + N.                      ***
C     *** Better performance will be obtained if          ***
C     ***      IWLEN .GE. PFREE + N                       ***
C     *** or better yet                                   ***
C     ***      IWLEN .GT. 1.2 * PFREE                     ***
C     Restriction: IWLEN .GE. PFREE-1
C
C PE(i) must be set to the the index in IW of the start of row I, or be
C     zero if row I has no off-diagonal entries. During execution,
C     it is used for both supervariables and elements:
C       * Principal supervariable I:  index into IW of the
C               list of supervariable I.  A supervariable
C               represents one or more rows of the matrix
C               with identical pattern.
C       * Non-principal supervariable I:  if I has been absorbed
C               into another supervariable J, then PE(I) = -J.
C               That is, J has the same pattern as I.
C               Note that J might later be absorbed into another
C               supervariable J2, in which case PE(I) is still -J,
C               and PE(J) = -J2.
C       * Unabsorbed element E:  the index into IW of the list
C               of element E.  Element E is created when
C               the supervariable of the same name is selected as
C               the pivot.
C       * Absorbed element E:  if element E is absorbed into element
C               E2, then PE(E) = -E2.  This occurs when one of its
C               variables is eliminated and when the pattern of
C               E (that is, Le) is found to be a subset of the pattern
C               of E2 (that is, Le2).  If element E is "null" (it has
C               no entries outside its pivot block), then PE(E) = 0.
C
C     On output, PE holds the assembly tree/forest, which implicitly
C     represents a pivot order with identical fill-in as the actual
C     order (via a depth-first search of the tree). If NV(I) .GT. 0,
C     then I represents a node in the assembly tree, and the parent of
C     I is -PE(I), or zero if I is a root. If NV(I)=0, then (I,-PE(I))
C     represents an edge in a subtree, the root of which is a node in
C     the assembly tree.
C
C PFREE must be set to the position in IW of the first free variable.
C     During execution, additional data is placed in IW, and PFREE is
C     modified so that components  of IW from PFREE are free.
C     On output, PFREE is set equal to the size of IW that would have
C     caused no compressions to occur.  If NCMPA is zero, then
C     PFREE (on output) is less than or equal to IWLEN, and the space
C     IW(PFREE+1 ... IWLEN) was not used. Otherwise, PFREE (on output)
C     is greater than IWLEN, and all the memory in IW was used.
C
C LEN(I) must be set to hold the number of entries in row I of the
C     matrix, excluding the diagonal.  The contents of LEN(1..N) are
C     undefined on output.
C
C IW(1..PFREE-1) must be set to  hold the patterns of the rows of
C     the matrix.  The matrix must be symmetric, and both upper and
C     lower triangular parts must be present.  The diagonal must not be
C     present.  Row I is held as follows:
C               IW(PE(I)...PE(I) + LEN(I) - 1) must hold the list of
C               column indices for entries in row I (simple
C               supervariables), excluding the diagonal.  All
C               supervariables start with one row/column each
C               (supervariable I is just row I). If LEN(I) is zero on
C               input, then PE(I) is ignored on input. Note that the
C               rows need not be in any particular order, and there may
C               be empty space between the rows.
C     During execution, the supervariable I experiences fill-in. This
C     is represented by constructing a list of the elements that cause
C     fill-in in supervariable I:
C               IE(PE(i)...PE(I) + ELEN(I) - 1) is the list of elements
C               that contain I. This list is kept short by removing
C               absorbed elements. IW(PE(I)+ELEN(I)...PE(I)+LEN(I)-1)
C               is the list of supervariables in I. This list is kept
C               short by removing nonprincipal variables, and any entry
C               J that is also contained in at least one of the
C               elements in the list for I.
C     When supervariable I is selected as pivot, we create an element E
C     of the same name (E=I):
C               IE(PE(E)..PE(E)+LEN(E)-1) is the list of supervariables
C                in element E.
C     An element represents the fill-in that occurs when supervariable
C     I is selected as pivot.
C     CAUTION:  THE INPUT MATRIX IS OVERWRITTEN DURING COMPUTATION.
C     The contents of IW are undefined on output.
C
C NV(I) need not be set. During execution, ABS(NV(I)) is equal to the
C     number of rows represented by the principal supervariable I. If I
C     is a nonprincipal variable, then NV(I) = 0. Initially, NV(I) = 1
C     for all I.  NV(I) .LT. 0 signifies that I is a principal variable
C     in the pattern Lme of the current pivot element ME. On output,
C     NV(E) holds the true degree of element E at the time it was
C     created (including the diagonal part).
C
C ELEN(I) need not be set. See the description of IW above. At the
C     start of execution, ELEN(I) is set to zero. For a supervariable,
C     ELEN(I) is the number of elements in the list for supervariable
C     I. For an element, ELEN(E) is the negation of the position in the
C     pivot sequence of the supervariable that generated it. ELEN(I)=0
C     if I is nonprincipal.
C     On output ELEN(1..N) holds the inverse permutation (the same
C     as the 'INVP' argument in Sparspak). That is, if K = ELEN(I),
C     then row I is the Kth pivot row.  Row I of A appears as the
C     (ELEN(I))-th row in the permuted matrix, PAP^T.
C
C LAST(I) need not be set on input. In a degree list, LAST(I) is the
C     supervariable preceding I, or zero if I is the head of the list.
C     In a hash bucket, LAST(I) is the hash key for I. LAST(HEAD(HASH))
C     is also used as the head of a hash bucket if HEAD(HASH) contains
C     a degree list (see HEAD, below).
C     On output, LAST(1..N) holds the permutation (the same as the
C     'PERM' argument in Sparspak). That is, if I = LAST(K), then row I
C     is the Kth pivot row.  Row LAST(K) of A is the K-th row in the
C     permuted matrix, PAP^T.
C
C
C DEGREE need not be set on input. If I is a supervariable and sparse,
C     then DEGREE(I) holds the current approximation of the external
C     degree of row I (an upper bound). The external degree is the
C     number of entries in row I, minus ABS(NV(I)) (the diagonal
C     part). The bound is equal to the external degree if ELEN(I) is
C     less than or equal to two. We also use the term "external degree"
C     for elements E to refer to |Le \ Lme|. If I is full in the reduced
C     matrix, then DEGREE(I)=N+1. If I is dense in the reduced matrix,
C     then DEGREE(I)=N+1+last_approximate_external_deg of I.
C     All dense rows are stored in the list pointed by HEAD(N).
C     Quasi dense rows are stored first, and are followed by full rows
C     in the reduced matrix. LASTD holds the last row in
C     this list of dense rows or is zero if the list is empty.
C
C HEAD(DEG) need not be set on input. HEAD is used for degree lists.
C     HEAD(DEG) is the first supervariable in a degree list (all
C     supervariables I in a degree list DEG have the same approximate
C     degree, namely, DEG = DEGREE(I)). If the list DEG is empty then
C     HEAD(DEG) = 0.
C     During supervariable detection HEAD(HASH) also serves as a
C     pointer to a hash bucket.
C     If HEAD(HASH) .GT. 0, there is a degree list of degree HASH. The
C     hash bucket head pointer is LAST(HEAD(HASH)).
C     If HEAD(HASH) = 0, then the degree list and hash bucket are
C     both empty.
C     If HEAD(HASH) .LT. 0, then the degree list is empty, and
C     -HEAD(HASH) is the head of the hash bucket.
C     After supervariable detection is complete, all hash buckets are
C     empty, and the (LAST(HEAD(HASH)) = 0) condition is restored for
C     the non-empty degree lists.
C
C DENXT(I) need not be set on input. For supervariable I, DENXT(I) is
C     the supervariable following I in a link list, or zero if I is
C     the last in the list. Used for two kinds of lists: degree lists
C     and hash buckets (a supervariable can be in only one kind of
C     list at a time). For element E, DENXT(E) is the number of
C     variables with dense or full rows in the element E.
C
C W(I) need not be set on input. The flag array W determines the status
C     of elements and variables, and the external degree of elements.
C     For elements:
C          if W(E) = 0, then the element E is absorbed.
C          if W(E) .GE. WFLG, then W(E)-WFLG is the size of the set
C               |Le \ Lme|, in terms of nonzeros (the sum of ABS(NV(I))
C               for each principal variable I that is both in the
C               pattern of element E and NOT in the pattern of the
C               current pivot element, ME).
C          if WFLG .GT. WE(E) .GT. 0, then E is not absorbed and has
C               not yet been seen in the scan of the element lists in
C               the computation of |Le\Lme| in loop 150 below.
C               ***SD: change comment to remove reference to label***
C     For variables:
C          during supervariable detection, if W(J) .NE. WFLG then J is
C          not in the pattern of variable I.
C     The W array is initialized by setting W(I) = 1 for all I, and by
C     setting WFLG = 2. It is reinitialized if WFLG becomes too large
C     (to ensure that WFLG+N does not cause integer overflow).
C
C ICNTL is an INTEGER array of length 10 that contains control
C     parameters and must be set by the user. Default values for the
C     components may be set by a call to MC47ID.
C
C RJNFO is an REAL (DOUBLE PRECISION in  D version) array of length 7
C     that need not be set by the user. This array supplies information
C     on the execution of MC47BD.
C     RJNFO(1) gives forecast number of reals to hold the factorization
C     RJNFO(2) gives the forecast number of flops required by the
C     factorization if no pivoting is performed.
C
C Local variables:
C ---------------
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, HASH, HMOD, I,
     $     IDUMMY, ILAST, INEXT, IOVFLO,J, JDUMMY, JLAST, JNEXT, K,
     $     KNT1, KNT2, KNT3, LASTD,  LENJ, LN, MAXMEM, ME,
     $     MEM, MINDEG, NBD, NCMPA, NDME, NEL, NELME, NEWMEM,
     $     NFULL, NLEFT, NRLADU, NVI, NVJ, NVPIV, P, P1, P2, P3, PDST,
     $     PEE, PEE1, PEND, PJ, PME, PME1, PME2, PN, PSRC, RSTRT,
     $     SLENME, THRESH, THRESM, WE, WFLG, WNVI,X
     $
      DOUBLE PRECISION RELDEN, SM, STD, OPS
      LOGICAL IDENSE
C
C DEG:        the degree of a variable or element
C DEGME:      size (no. of variables), |Lme|, of the current element,
C             ME (= DEGREE(ME))
C DEXT:       external degree, |Le \ Lme|, of some element E
C DMAX:       largest |Le| seen so far
C E:          an element
C ELENME:     the length, ELEN(ME), of element list of pivotal var.
C ELN:        the length, ELEN(...), of an element list
C HASH:       the computed value of the hash function
C HMOD:       the hash function is computed modulo HMOD = MAX(1,N-1)
C I:          a supervariable
C IDUMMY:     loop counter
C ILAST:      the entry in a link list preceding I
C INEXT:      the entry in a link list following I
C IOVFLO:     local copy of ICNTL(5)
C J:          a supervariable
C JDUMMY:     loop counter
C JLAST:      the entry in a link list preceding J
C JNEXT:      the entry in a link list, or path, following J
C K:          the pivot order of an element or variable
C KNT1:       loop counter used during element construction
C KNT2:       loop counter used during element construction
C KNT3:       loop counter used during element construction
C LASTD:      index of the last row in the list of dense rows
C LENJ:       LEN(J)
C LN:         length of a supervariable list
C MAXMEM:     amount of memory needed for no compressions
C ME:         current supervariable being eliminated, and the
C                     current element created by eliminating that
C                     supervariable
C MEM:        memory in use assuming no compressions have occurred
C MINDEG:     current approximate minimum degree
C NBD:        total number of dense rows selected
C NCMPA:      counter for the number of times IW was compressed
C NDME  :     number of dense rows adjacent to me
C NEL:        number of pivots selected so far
C NELME:      number of pivots selected when reaching the root
C NEWMEM:     amount of new memory needed for current pivot element
C NFULL:      total number of full rows detected.
C NLEFT:      N-NEL, the number of nonpivotal rows/columns remaining
C NRLADU:     counter for the forecast number of reals in matrix factor
C NVI:        the number of variables in a supervariable I (= NV(I))
C NVJ:        the number of variables in a supervariable J (= NV(J))
C NVPIV:      number of pivots in current element
C P:          pointer into lots of things
C P1:         pe (i) for some variable i (start of element list)
C P2:         pe (i) + elen (i) -  1 for some var. i (end of el. list)
C P3:         index of first supervariable in clean list
C PJ:         pointer into an element or variable
C PDST:       destination pointer, for compression
C PEE:        pointer into element E
C PEE1:       pointer into element E
C PEND:       end of memory to compress
C PME:        pointer into the current element (PME1...PME2)
C PME1:       the current element, ME, is stored in IW(PME1...PME2)
C PME2:       the end of the current element
C PN:         pointer into a "clean" variable, also used to compress
C PSRC:       source pointer, for compression
C RSTRT:      counter for the number of restarts carried out
C SLENME:     number of variables in variable list of pivotal variable
C THRESH:     local copy of ICNTL(4)
C THRESM :    local integer holding the threshold used to detect quasi
C             dense rows. When quasi dense rows are reintegrated in the
C             graph to be processed then THRESM is modified.
C WE:         W(E)
C WFLG:       used for flagging the W array.  See description of W.
C WNVI:       WFLG-NV(I)
C X:          either a supervariable or an element
C
C OPS:        counter for forecast number of flops
C RELDEN :    holds average density to set THRESM automatically
C SM:         counter used for forming standard deviation
C STD:        standard deviation
C
C IDENSE is true if supervariable I is dense
C
C -------------------------------------------------------------------
C  FUNCTIONS CALLED:
C -------------------------------------------------------------------
      INTRINSIC MAX, MIN, MOD
C ====================================================================
C  INITIALIZATIONS
C ====================================================================

      DO 2 I = 1,10
         RJNFO(I) = 0.0
         JNFO(I) = 0
 2    CONTINUE
      DMAX = 0
      HMOD = MAX (1, N-1)
      IOVFLO = ICNTL(5)
      LASTD = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      MINDEG = 1
      NBD   = 0
      NCMPA = 0
      NEL = 0
      NFULL  = 0
      NRLADU = 0
      RSTRT = 0
      OPS = 0.00
      THRESH = ICNTL(4)
      WFLG = 2

C     ------------------------------------------------------
C     Experiments with automatic setting of parameter THRESH.
C     ------------------------------------------------------
      IF (THRESH.GT.0) THEN
         THRESM  = 0
         RELDEN = 0.0
         SM = 0
C        ----------------------------------------------------------
C        initialize arrays and eliminate rows with no off-diag. nz.
C        ----------------------------------------------------------
         DO 5 I=1,N
            THRESM = MAX(THRESM, LEN(I))
            IF (LEN(I).GT.0) THEN
               RELDEN = RELDEN + LEN(I)
               SM = SM + (LEN(I) * LEN(I))
            END IF
            LAST (I) = 0
            HEAD (I) = 0
            NV (I) = 1
            DEGREE (I) = LEN (I)
            IF (DEGREE(I) .EQ. 0) THEN
               NEL = NEL + 1
               ELEN (I) = -NEL
               PE (I) = 0
               W (I) = 0
               NRLADU = NRLADU + 1
               OPS = OPS + 1
            ELSE
               W (I) = 1
               ELEN (I) = 0
            ENDIF
 5       CONTINUE
         IF (N .EQ. NEL) GOTO 265

         RELDEN = RELDEN/(N-NEL)
C        RELDEN holds average row length
         SM = SM/(N-NEL-NFULL) - RELDEN*RELDEN
         STD = SQRT(ABS(SM))
C        STD holds standard deviation of the row lengths
         IF (STD .LE. RELDEN) THEN
            THRESM = -1
         ELSE
            THRESM = INT(9*RELDEN + 0.5*STD*((STD/(RELDEN+0.01))**1.5)+
     *           2*RELDEN*RELDEN/(STD+0.01) +1)
         END IF
C     ------------------------------------------------------
C     end automatic setting of THRESM
C     ------------------------------------------------------

      ELSE
         THRESM = THRESH
         DO 10 I = 1, N
            LAST (I) = 0
            HEAD (I) = 0
            NV (I) = 1
            DEGREE (I) = LEN (I)
            IF (DEGREE(I) .EQ. 0) THEN
               NEL = NEL + 1
               ELEN (I) = -NEL
               PE (I) = 0
               W (I) = 0
               NRLADU = NRLADU + 1
               OPS = OPS + 1
            ELSE
               W (I) = 1
               ELEN (I) = 0
            ENDIF
 10      CONTINUE
      ENDIF
      IF (THRESM.GE.0) THEN
         IF (THRESM.GE.N) THEN
C           full rows only
            THRESM = -1
         ELSE IF (THRESM.EQ.0) THEN
            THRESM = N
         ENDIF
      ENDIF

C     ----------------------------------------------------------------
C     initialize degree lists
C     ----------------------------------------------------------------
      DO 20 I = 1, N
         DEG = DEGREE (I)
         IF (DEG .GT. 0) THEN
C           ----------------------------------------------------------
C           place i in the degree list corresponding to its degree
C           or in the dense row list if i is dense
C           ----------------------------------------------------------
C           test for row density
            IF ( (THRESM.GE.0) .AND.
     &           (DEG+1.GE.THRESM.OR.DEG+1.GE.N-NEL )) THEN
C              I is dense and will be inserted in the degree
C              list of N
               NBD = NBD+1
               IF (DEG+1.NE.N-NEL) THEN
C                 I is quasi dense
                  DEGREE(I) = DEGREE(I)+N+1
C                 insert I at the beginning of degree list of n
                  DEG = N
                  INEXT = HEAD (DEG)
                  IF (INEXT .NE. 0) LAST (INEXT) = I
                  DENXT (I) = INEXT
                  HEAD (DEG) = I
                  LAST(I)  = 0
                  IF (LASTD.EQ.0) THEN
                     LASTD=I
                  END IF
               ELSE
C                 I is full
                  NFULL = NFULL+1
                  DEGREE(I) = N+1
C                 insert I at the end of degree list of n
                  DEG = N
                  IF (LASTD.EQ.0) THEN
C                    degree list is empty
                     LASTD     = I
                     HEAD(DEG) = I
                     DENXT(I)   = 0
                     LAST(I)   = 0
                  ELSE
C                     IF (NFULL.EQ.1) THEN
C                       First full row encountered
                        DENXT(LASTD) = I
                        LAST(I)     = LASTD
                        LASTD       = I
                        DENXT(I)     = 0
C                     ELSE
C                       Absorb I into LASTD (first full row found)
C                        PE(I) = - LASTD
C                        NV(LASTD) = NV(LASTD) + NV(I)
C                        NV(I) = 0
C                        ELEN(I) = 0
C                     END IF
                  ENDIF
               ENDIF
            ELSE
C              place i in the degree list corresponding to its degree
               INEXT = HEAD (DEG)
               IF (INEXT .NE. 0) LAST (INEXT) = I
               DENXT (I) = INEXT
               HEAD (DEG) = I
            ENDIF
         ENDIF
 20   CONTINUE

C     We suppress dense row selection if none of them was found in A
C     in the 1st pass
      IF (NBD.EQ.0 .AND. THRESH.GT.0) THEN
         THRESM = -1
      END IF
C
C ====================================================================
C  WHILE (selecting pivots) DO
C ====================================================================

 30   IF (NEL .LT. N) THEN

C ==================================================================
C  GET PIVOT OF MINIMUM APPROXIMATE DEGREE
C ==================================================================
C       -------------------------------------------------------------
C       find next supervariable for elimination
C       -------------------------------------------------------------
         DO 40 DEG = MINDEG, N
            ME = HEAD (DEG)
            IF (ME .GT. 0) GO TO 50
 40      CONTINUE
 50      MINDEG = DEG
         IF (DEG.LT.N)  THEN
C       -------------------------------------------------------------
C       remove chosen variable from linked list
C       -------------------------------------------------------------
            INEXT = DENXT (ME)
            IF (INEXT .NE. 0) LAST (INEXT) = 0
            HEAD (DEG) = INEXT
         ELSE
            IF (DEGREE(ME).EQ.N+1) GO TO 263
C DEGREE(ME).GT.N+1 so ME is quasi dense
C RESTARTING STRATEGY
C         FOR EACH  quasi dense row d
C           1/ insert d in the degree list according to the
C            value degree(d)-(N+1) (updating MINDEG)
C           2/ Build the adjacency list of d in the quotient graph
C              update DENXT(e_me)= DENXT(e_me)-NV(ME)
C           4/ get back to min degree process
C
C           THRESM > 0 because quasi dense rows were selected
C           While loop: ME is the current dense row
C           make sure that WFLG is not too large
            RSTRT = RSTRT + 1
            RELDEN = 0.0
            SM = 0
            IF (WFLG .GT. IOVFLO-NBD-1) THEN
               DO  51 X = 1, N
                  IF (W (X) .NE. 0) W (X) = 1
 51            CONTINUE
               WFLG = 2
            END IF
            WFLG = WFLG + 1
            DO 57 IDUMMY = 1,N

C           ---------------------------------------------------------
C           remove chosen variable from link list
C           ---------------------------------------------------------
               INEXT = DENXT (ME)
               IF (INEXT .NE. 0) THEN
                  LAST (INEXT) = 0
               ELSE
                  LASTD = 0
               ENDIF
C           ----------------------------------------------------------
c           build adjacency list of ME in quotient graph
C           and calculate its external degree in ndense(me)
C           ----------------------------------------------------------
               DENXT(ME) = 0
C              Flag ME as having been considered in this calculation
               W(ME)      = WFLG
               P1 = PE(ME)
               P2 = P1 + LEN(ME) -1
C           LN-1 holds the pointer in IW to last elt/var in adj list
C              of ME.  LEN(ME) will then be set to LN-P1
C           ELN-1 hold the pointer in IW to  last elt in in adj list
C              of ME.  ELEN(ME) will then be set to ELN-P1
C           element adjacent to ME
               LN       = P1
               ELN      = P1
               DO 55 P=P1,P2
                  E= IW(P)
                  IF (W(E).EQ.WFLG) GO TO 55
                  W(E) = WFLG
C             -------------------------------------------
C             Ensure that E is an unabsorbed element or a quasi dense
C                 row and flag it
C             -------------------------------------------
                  DO 52 JDUMMY = 1,N
                     IF ( PE(E) .GE. 0 ) GOTO 53
                     E = -PE(E)
                     IF (W(E) .EQ.WFLG) GOTO 55
                     W(E) = WFLG
 52               CONTINUE
 53               IF (ELEN(E).LT.0) THEN
C                    E is a new element in adj(ME)
                     DENXT(E) = DENXT(E) - NV(ME)
C                    Move first entry in ME's list of adjacent variables
C                    to the end
                     IW(LN) = IW(ELN)
C                    Place E at end of ME's list of adjacent elements
                     IW(ELN) = E
                     LN  = LN+1
                     ELN = ELN + 1
C                    update ndense of ME with all unflagged dense
C                    rows in E
                     PEE1 = PE(E)
                     DO 54 PEE = PEE1, PEE1+LEN(E)-1
                        X = IW(PEE)
                        IF ((ELEN(X).GE.0).AND.(W(X).NE.WFLG)) THEN
C                          X is a dense row
                           DENXT(ME) = DENXT(ME) + NV(X)
                           W(X) = WFLG
                        ENDIF
 54                  CONTINUE
                  ELSE
C                    E is a dense row
                     DENXT(ME) = DENXT(ME) + NV(E)
C                    Place E at end of ME's list of adjacent variables
                     IW(LN)=E
                     LN = LN+1
                  ENDIF
 55            CONTINUE

C           ----------------------------------------------
C           DEGREE(ME)-(N+1) holds last external degree computed
C           when ME was detected as dense
C           DENXT(ME) is the exact external degree of ME
C           ----------------------------------------------
               WFLG     = WFLG + 1
               LEN(ME)  = LN-P1
               ELEN(ME) = ELN- P1
               NDME = DENXT(ME)+NV(ME)
C            If we want to select ME as full (NDME.EQ.NBD)
C            or quasi dense (NDME.GE.THRESM) then
C            denxt(of elements adjacent to ME) should be updated
               IF (DENXT(ME).EQ.0) DENXT(ME) =1
C           ---------------------------------------------------------
C           place ME in the degree list of DENXT(ME), update DEGREE
C           ---------------------------------------------------------
C               IF (DEGREE(ME)+NV(ME) .LT. NBD  ) THEN
               IF (NDME .LT. NBD) THEN
C                 ME is not full
                  RELDEN = RELDEN + NV(ME)*NDME
                  SM = SM + NV(ME)*NDME*NDME
                  DEGREE(ME) = DENXT(ME)
                  DEG = DEGREE(ME)
                  MINDEG = MIN(DEG,MINDEG)
                  JNEXT = HEAD(DEG)
                  IF (JNEXT.NE. 0) LAST (JNEXT) = ME
                  DENXT(ME) = JNEXT
                  HEAD(DEG) = ME
               ELSE
C                 ME is full
                  DEGREE(ME) = N+1
                  DEG = DENXT(ME)
                  MINDEG = MIN(DEG,MINDEG)
                  DEG = N

C                 Update DENXT of all elements in the list of elements
C                 adjacent to ME
                  P1 = PE(ME)
                  P2 = P1 + ELEN(ME) - 1
                  DO 56 PJ=P1,P2
                     E= IW(PJ)
                     DENXT (E) = DENXT(E) + NV(ME)
 56               CONTINUE
C                  insert ME in the list of dense rows
                  DEG = N
C                 ME at the end of the list
                  NFULL = NFULL +NV(ME)
                  IF (LASTD.EQ.0) THEN
C                        degree list is empty
                     LASTD     = ME
                     HEAD(N) = ME
                     DENXT(ME)   = 0
                     LAST(ME)   = 0
                     IF (INEXT.EQ.0) INEXT = LASTD
                  ELSE
C                     IF (NFULL.EQ.NV(ME)) THEN
C                           First full row encountered
                        DENXT(LASTD) = ME
                        LAST(ME)     = LASTD
                        LASTD        = ME
                        DENXT(ME)     = 0
                        IF (INEXT.EQ.0) INEXT = LASTD
C                     ELSE
C                   Absorb ME into LASTD (first full row found)
C                        PE(ME) = - LASTD
C                        NV(LASTD) = NV(LASTD) + NV(ME)
C                        NV(ME) = 0
C                        ELEN(ME) = 0
C                     END IF
                  ENDIF
               END IF

C           ------------------------------
C           process next quasi dense row
C           ------------------------------
               ME    = INEXT
               IF (ME.EQ.0) GO TO 58
               IF (DEGREE(ME).LE.(N+1) ) GOTO 58
 57         CONTINUE
 58         HEAD (N) = ME
C           ---------------------------------------
C           update dense row selection strategy
C           -------------------------------------
            IF (NBD.EQ.NFULL) THEN
               RELDEN = 0
               SM = 0
            ELSE
               RELDEN = (RELDEN + NFULL*NBD)/(NBD)
               SM = (SM + NFULL*NBD*NBD)/(NBD) - RELDEN*RELDEN
            END IF
            STD = SQRT(ABS(SM))
            THRESM = INT(9*RELDEN+0.5*STD*((STD/(RELDEN + 0.01))**1.5)
     *           + 2*RELDEN*RELDEN/(STD+0.01) +1)
            THRESM = MIN(THRESM,NBD)
            IF (THRESM.GE.NBD) THEN
               THRESM = N
            END IF
            NBD = NFULL
C           get back to min degree elimination loop
            GOTO 30
C         -------------------------------------------------------------
C         -------------------------------------------------------------
         ENDIF
C       -------------------------------------------------------------
C       me represents the elimination of pivots nel+1 to nel+nv(me).
C       place me itself as the first in this set.  It will be moved
C       to the nel+nv(me) position when the permutation vectors are
C       computed.
C       -------------------------------------------------------------
         ELENME = ELEN (ME)
         ELEN (ME) = - (NEL + 1)
         NVPIV = NV (ME)
         NEL = NEL + NVPIV
         DENXT(ME) = 0

C ====================================================================
C  CONSTRUCT NEW ELEMENT
C ====================================================================
C
C       -------------------------------------------------------------
C       At this point, me is the pivotal supervariable.  It will be
C       converted into the current element.  Scan list of the
C       pivotal supervariable, me, setting tree pointers and
C       constructing new list of supervariables for the new element,
C       me.  p is a pointer to the current position in the old list.
C       -------------------------------------------------------------
C
C       flag the variable "me" as being in the front by negating nv(me)
         NV (ME) = -NVPIV
         DEGME = 0
         IF (ELENME .EQ. 0) THEN
C         ----------------------------------------------------------
C         There are no elements involved.
C         Construct the new element in place.
C         ----------------------------------------------------------
            PME1 = PE (ME)
            PME2 = PME1 - 1
            DO 60 P = PME1, PME1 + LEN (ME) - 1
               I = IW (P)
               NVI = NV (I)
               IF (NVI .GT. 0) THEN
C             ----------------------------------------------------
C             i is a principal variable not yet placed in the
C             generated element. Store i in new list
C             ----------------------------------------------------
                  DEGME = DEGME + NVI
C                 flag i as being in Lme by negating nv (i)
                  NV (I) = -NVI
                  PME2 = PME2 + 1
                  IW (PME2) = I

C             ----------------------------------------------------
C             remove variable i from degree list.
C             ----------------------------------------------------
C             only done for sparse rows
                  IF (DEGREE(I).LE.N) THEN
                     ILAST = LAST (I)
                     INEXT = DENXT (I)
                     IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                     IF (ILAST .NE. 0) THEN
                        DENXT (ILAST) = INEXT
                     ELSE
C                       i is at the head of the degree list
                        HEAD (DEGREE (I)) = INEXT
                     ENDIF
                  ELSE
C                    Dense rows remain dense so do not remove from list
                     DENXT(ME) = DENXT(ME) + NVI
                  ENDIF
               ENDIF
 60         CONTINUE
C           this element takes no new memory in iw:
            NEWMEM = 0
         ELSE
C         ----------------------------------------------------------
C         construct the new element in empty space, iw (pfree ...)
C         ----------------------------------------------------------
            P  = PE (ME)
            PME1 = PFREE
            SLENME = LEN (ME) - ELENME
            DO 120 KNT1 = 1, ELENME
C              search the elements in me.
               E = IW (P)
               P = P + 1
               PJ = PE (E)
               LN = LEN (E)
C           -------------------------------------------------------
C           search for different supervariables and add them to the
C           new list, compressing when necessary.
C           -------------------------------------------------------
               DO 110 KNT2 = 1, LN
                  I = IW (PJ)
                  PJ = PJ + 1
                  NVI = NV (I)
                  IF (NVI .GT. 0) THEN
C               -------------------------------------------------
C               compress iw, if necessary
C               -------------------------------------------------
                     IF (PFREE .GT. IWLEN) THEN
C                    prepare for compressing iw by adjusting
C                    pointers and lengths so that the lists being
C                    searched in the inner and outer loops contain
C                    only the remaining entries.
C                    ***** SD: Seperate compression subroutine tried
C                      but found to be inefficient in comparison ****
                        PE (ME) = P
                        LEN (ME) = LEN (ME) - KNT1
C                       Check if anything left in supervariable ME
                        IF (LEN (ME) .EQ. 0) PE (ME) = 0
                        PE (E) = PJ
                        LEN (E) = LN - KNT2
C                       Check if anything left in element E
                        IF (LEN (E) .EQ. 0) PE (E) = 0
                        NCMPA = NCMPA + 1
C                       store first item in pe
C                       set first entry to -item
                        DO 70 J = 1, N
                           PN = PE (J)
                           IF (PN .GT. 0) THEN
                              PE (J) = IW (PN)
                              IW (PN) = -J
                           ENDIF
 70                     CONTINUE

C                       psrc/pdst point to source/destination
                        PDST = 1
                        PSRC = 1
                        PEND = PME1 - 1

C                       while loop:
                        DO 91 IDUMMY = 1, IWLEN
                           IF (PSRC .GT. PEND) GO TO 95
C                          search for next negative entry
                           J = -IW (PSRC)
                           PSRC = PSRC + 1
                           IF (J .GT. 0) THEN
                              IW (PDST) = PE (J)
                              PE (J) = PDST
                              PDST = PDST + 1
C                     copy from source to destination
                              LENJ = LEN (J)
                              DO 90 KNT3 = 0, LENJ - 2
                                 IW (PDST + KNT3) = IW (PSRC + KNT3)
 90                           CONTINUE
                              PDST = PDST + LENJ - 1
                              PSRC = PSRC + LENJ - 1
                           ENDIF
 91                     END DO

C                       move the new partially-constructed element
 95                     P1 = PDST
                        DO 100 PSRC = PME1, PFREE - 1
                           IW (PDST) = IW (PSRC)
                           PDST = PDST + 1
 100                    CONTINUE
                        PME1 = P1
                        PFREE = PDST
                        PJ = PE (E)
                        P = PE (ME)
                     ENDIF

C               -------------------------------------------------
C               i is a principal variable not yet placed in Lme
C               store i in new list
C               -------------------------------------------------
                     DEGME = DEGME + NVI
C                    flag i as being in Lme by negating nv (i)
                     NV (I) = -NVI
                     IW (PFREE) = I
                     PFREE = PFREE + 1

C               -------------------------------------------------
C               remove variable i from degree link list
C               -------------------------------------------------
C                    only done for sparse rows
                     IF (DEGREE(I).LE.N) THEN
                        ILAST = LAST (I)
                        INEXT = DENXT (I)
                        IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                        IF (ILAST .NE. 0) THEN
                           DENXT (ILAST) = INEXT
                        ELSE
C                         i is at the head of the degree list
                           HEAD (DEGREE (I)) = INEXT
                        ENDIF
                     ELSE
C                    Dense rows remain dense so do not remove from list
                        DENXT(ME) = DENXT(ME) + NVI
                     ENDIF
                  ENDIF
 110           CONTINUE

C                set tree pointer and flag to indicate element e is
C                absorbed into new element me (the parent of e is me)
                  PE (E) = -ME
                  W (E) = 0
 120        CONTINUE

C           search the supervariables in me.
            KNT1 = ELENME + 1
            E = ME
            PJ = P
            LN = SLENME

C           -------------------------------------------------------
C           search for different supervariables and add them to the
C           new list, compressing when necessary.
C           -------------------------------------------------------
            DO 126 KNT2 = 1, LN
               I = IW (PJ)
               PJ = PJ + 1
               NVI = NV (I)
               IF (NVI .GT. 0) THEN
C               -------------------------------------------------
C               compress iw, if necessary
C               -------------------------------------------------
                  IF (PFREE .GT. IWLEN) THEN
C                 prepare for compressing iw by adjusting
C                 pointers and lengths so that the lists being
C                 searched in the inner and outer loops contain
C                 only the remaining entries.
                     PE (ME) = P
                     LEN (ME) = LEN (ME) - KNT1
C                    Check if anything left in supervariable ME
                     IF (LEN (ME) .EQ. 0) PE (ME) = 0
                     PE (E) = PJ
                     LEN (E) = LN - KNT2
C                    Check if anything left in element E
                     IF (LEN (E) .EQ. 0) PE (E) = 0
                     NCMPA = NCMPA + 1
C                    store first item in pe
C                    set first entry to -item
                     DO 121 J = 1, N
                        PN = PE (J)
                        IF (PN .GT. 0) THEN
                           PE (J) = IW (PN)
                           IW (PN) = -J
                        ENDIF
 121                 CONTINUE

C                    psrc/pdst point to source/destination
                     PDST = 1
                     PSRC = 1
                     PEND = PME1 - 1

C                 while loop:
C 122              CONTINUE
                     DO 123 IDUMMY = 1,IWLEN
                        IF (PSRC .GT. PEND) GO TO 124
C                       search for next negative entry
                        J = -IW (PSRC)
                        PSRC = PSRC + 1
                        IF (J .GT. 0) THEN
                           IW (PDST) = PE (J)
                           PE (J) = PDST
                           PDST = PDST + 1
C                          copy from source to destination
                           LENJ = LEN (J)
                           DO 122 KNT3 = 0, LENJ - 2
                              IW (PDST + KNT3) = IW (PSRC + KNT3)
 122                       CONTINUE
                           PDST = PDST + LENJ - 1
                           PSRC = PSRC + LENJ - 1
                        ENDIF
 123                 END DO

C                 move the new partially-constructed element
 124                 P1 = PDST
                     DO 125 PSRC = PME1, PFREE - 1
                        IW (PDST) = IW (PSRC)
                        PDST = PDST + 1
 125                 CONTINUE
                     PME1 = P1
                     PFREE = PDST
                     PJ = PE (E)
                     P = PE (ME)
                  END IF

C               -------------------------------------------------
C               i is a principal variable not yet placed in Lme
C               store i in new list
C               -------------------------------------------------
                  DEGME = DEGME + NVI
C                 flag i as being in Lme by negating nv (i)
                  NV (I) = -NVI
                  IW (PFREE) = I
                  PFREE = PFREE + 1

C               -------------------------------------------------
C               remove variable i from degree link list
C               -------------------------------------------------
C                 only done for sparse rows
                  IF (DEGREE(I).LE.N) THEN
                     ILAST = LAST (I)
                     INEXT = DENXT (I)
                     IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                     IF (ILAST .NE. 0) THEN
                        DENXT (ILAST) = INEXT
                     ELSE
C                 i is at the head of the degree list
                        HEAD (DEGREE (I)) = INEXT
                     ENDIF
                  ELSE
C                    Dense rows remain dense so do not remove from list
                     DENXT(ME) = DENXT(ME) + NVI
                  ENDIF
               ENDIF
 126           CONTINUE

            PME2 = PFREE - 1
C           this element takes newmem new memory in iw (possibly zero)
            NEWMEM = PFREE - PME1
            MEM = MEM + NEWMEM
            MAXMEM = MAX (MAXMEM, MEM)
         ENDIF

C       -------------------------------------------------------------
C       me has now been converted into an element in iw (pme1..pme2)
C       -------------------------------------------------------------
C       degme holds the external degree of new element
         DEGREE (ME) = DEGME
         PE (ME) = PME1
         LEN (ME) = PME2 - PME1 + 1

C       -------------------------------------------------------------
C       make sure that wflg is not too large.  With the current
C       value of wflg, wflg+n must not cause integer overflow
C       -------------------------------------------------------------
         IF (WFLG .GT. IOVFLO-N) THEN
            DO 130 X = 1, N
               IF (W (X) .NE. 0) W (X) = 1
 130        CONTINUE
            WFLG = 2
         ENDIF

C ====================================================================
C   COMPUTE (w(e) - wflg) = |Le(G')\Lme(G')| FOR ALL ELEMENTS
C   where G' is the subgraph of G containing just the sparse rows)
C ====================================================================
C       -------------------------------------------------------------
C       Scan 1:  compute the external degrees of elements touched
C       with respect to the current element.  That is:
C            (w (e) - wflg) = |Le \ Lme|
C       for each element e involving a supervariable in Lme.
C       The notation Le refers to the pattern (list of
C       supervariables) of a previous element e, where e is not yet
C       absorbed, stored in iw (pe (e) + 1 ... pe (e) + iw (pe (e))).
C       The notation Lme refers to the pattern of the current element
C       (stored in iw (pme1..pme2)).
C       aggressive absorption is possible only if DENXT(ME) = NBD
C       which is true when only full rows have been selected.
C       -------------------------------------------------------------
         IF (NBD.GT.0) THEN
C           Dense rows have been found
            DO 150 PME = PME1, PME2
               I = IW (PME)
c              skip dense rows
               IF (DEGREE(I).GT.N) GOTO 150
               ELN = ELEN (I)
               IF (ELN .GT. 0) THEN
C              note that nv (i) has been negated to denote i in Lme:
                  NVI = -NV (I)
                  WNVI = WFLG - NVI
                  DO 140 P = PE (I), PE (I) + ELN - 1
                     E = IW (P)
                     WE = W (E)
                     IF (WE .GE. WFLG) THEN
C                    unabsorbed element e has been seen in this loop
                        WE = WE - NVI
                     ELSE IF (WE .NE. 0) THEN
C                    e is an unabsorbed element - this is
C                    the first we have seen e in all of Scan 1
                        WE = DEGREE (E) + WNVI - DENXT(E)
                     ENDIF
                     W (E) = WE
 140              CONTINUE
               ENDIF
 150        CONTINUE
         ELSE
C           No dense rows have been found
            DO 152 PME = PME1, PME2
               I = IW (PME)
               ELN = ELEN (I)
               IF (ELN .GT. 0) THEN
C           note that nv (i) has been negated to denote i in Lme:
                  NVI = -NV (I)
                  WNVI = WFLG - NVI
                  DO 151 P = PE (I), PE (I) + ELN - 1
                     E = IW (P)
                     WE = W (E)
                     IF (WE .GE. WFLG) THEN
C                    unabsorbed element e has been seen in this loop
                        WE = WE - NVI
                     ELSE IF (WE .NE. 0) THEN
C                    e is an unabsorbed element - this is
C                    the first we have seen e in all of Scan 1
                        WE = DEGREE (E) + WNVI
                     ENDIF
                     W (E) = WE
 151              CONTINUE
               ENDIF
 152        CONTINUE
         END IF

C ====================================================================
C  DEGREE UPDATE AND ELEMENT ABSORPTION
C ====================================================================

C       -------------------------------------------------------------
C       Scan 2:  for each sparse i in Lme, sum up the external degrees
C       of each Le for the elements e appearing within i, plus the
C       supervariables in i.  Place i in hash list.
C       -------------------------------------------------------------
         IF (NBD.GT.0) THEN
C           Dense rows have been found
            DO 180 PME = PME1, PME2
               I = IW (PME)
C              skip dense rows
               IF (DEGREE(I).GT.N) GOTO 180
C              remove absorbed elements from the list for i
               P1 = PE (I)
               P2 = P1 + ELEN (I) - 1
               PN = P1
               HASH = 0
               DEG = 0

C         ----------------------------------------------------------
C         scan the element list associated with supervariable i
C         ----------------------------------------------------------
               DO 160 P = P1, P2
                  E = IW (P)
C                 dext = | Le | - | (Le \cap Lme)\D | - DENXT(e)
                  DEXT = W (E) - WFLG
                  IF (DEXT .GT. 0) THEN
                     DEG = DEG + DEXT
                     IW (PN) = E
                     PN = PN + 1
                     HASH = HASH+E
                  ELSE IF ((DEXT .EQ. 0) .AND.
     &                    (DENXT(ME).EQ.NBD)) THEN
C             aggressive absorption: e is not adjacent to me, but
C             |Le(G') \ Lme(G')| is 0 and all dense rows
C             are in me, so absorb it into me
                     PE (E) = -ME
                     W (E)  = 0
                  ELSE IF (DEXT.EQ.0) THEN
                     IW(PN) = E
                     PN     = PN+1
                     HASH = HASH + E
                  ENDIF
 160           CONTINUE

C           count the number of elements in i (including me):
               ELEN (I) = PN - P1 + 1

C         ----------------------------------------------------------
C         scan the supervariables in the list associated with i
C         ----------------------------------------------------------
               P3 = PN
               DO 170 P = P2 + 1, P1 + LEN (I) - 1
                  J = IW (P)
                  NVJ = NV (J)
                  IF (NVJ .GT. 0) THEN
C                 j is unabsorbed, and not in Lme.
C                 add to degree and add to new list
C                 add degree only of sparse rows.
                     IF (DEGREE(J).LE.N) DEG=DEG+NVJ
                     IW (PN) = J
                     PN = PN + 1
                     HASH = HASH + J
                  ENDIF
 170           CONTINUE

C         ----------------------------------------------------------
C         update the degree and check for mass elimination
C         ----------------------------------------------------------
               IF ((DEG .EQ. 0).AND.(DENXT(ME).EQ.NBD)) THEN
C              mass elimination only possible when all dense rows
C              are in ME
C           -------------------------------------------------------
C           mass elimination - supervariable i can be eliminated
C           -------------------------------------------------------
                  PE (I) = -ME
                  NVI = -NV (I)
                  DEGME = DEGME - NVI
                  NVPIV = NVPIV + NVI
                  NEL = NEL + NVI
                  NV (I) = 0
                  ELEN (I) = 0
               ELSE
C           -------------------------------------------------------
C           update the upper-bound degree of i
C           A bound for the new external degree is the old bound plus
C           the size of the generated element
C           -------------------------------------------------------
C           the following degree does not yet include the size
C           of the current element, which is added later:
                  DEGREE(I) = MIN (DEG+NBD-DENXT(ME), DEGREE(I))

C           -------------------------------------------------------
C           add me to the list for i
C           -------------------------------------------------------
C              move first supervariable to end of list
                  IW (PN) = IW (P3)
C              move first element to end of element part of list
                  IW (P3) = IW (P1)
C              add new element to front of list.
                  IW (P1) = ME
C              store the new length of the list in len (i)
                  LEN (I) = PN - P1 + 1

C           -------------------------------------------------------
C           place in hash bucket.  Save hash key of i in last (i).
C           -------------------------------------------------------
                  HASH = ABS(MOD (HASH, HMOD)) + 1
                  J = HEAD (HASH)
                  IF (J .LE. 0) THEN
C                the degree list is empty, hash head is -j
                     DENXT (I) = -J
                     HEAD (HASH) = -I
                  ELSE
C                degree list is not empty - has j as its head
C                last is hash head
                     DENXT (I) = LAST (J)
                     LAST (J) = I
                  ENDIF
                  LAST (I) = HASH
               ENDIF
 180        CONTINUE
         ELSE
C           No dense rows have been found
            DO 183 PME = PME1, PME2
               I = IW (PME)
C              remove absorbed elements from the list for i
               P1 = PE (I)
               P2 = P1 + ELEN (I) - 1
               PN = P1
               HASH = 0
               DEG = 0

C              -------------------------------------------------------
C              scan the element list associated with supervariable i
C              -------------------------------------------------------
               DO 181 P = P1, P2
                  E = IW (P)
C                 dext = | Le | - | (Le \cap Lme)\D | - DENXT(e)
                  DEXT = W (E) - WFLG
                  IF (DEXT .GT. 0) THEN
                     DEG = DEG + DEXT
                     IW (PN) = E
                     PN = PN + 1
                     HASH = HASH + E
                  ELSE IF (DEXT .EQ. 0) THEN
C                  aggressive absorption: e is not adjacent to me, but
C                  |Le(G') \ Lme(G')| is 0, so absorb it into me
                     PE (E) = -ME
                     W (E)  = 0
                  ENDIF
 181           CONTINUE

C           count the number of elements in i (including me):
               ELEN (I) = PN - P1 + 1

C         ----------------------------------------------------------
C         scan the supervariables in the list associated with i
C         ----------------------------------------------------------
               P3 = PN
               DO 182 P = P2 + 1, P1 + LEN (I) - 1
                  J = IW (P)
                  NVJ = NV (J)
                  IF (NVJ .GT. 0) THEN
C                 j is unabsorbed, and not in Lme.
C                 add to degree and add to new list
                     DEG=DEG+NVJ
                     IW (PN) = J
                     PN = PN + 1
                     HASH = HASH + J
                  ENDIF
 182           CONTINUE

C         ----------------------------------------------------------
C         update the degree and check for mass elimination
C         ----------------------------------------------------------
               IF (DEG .EQ. 0) THEN
C           -------------------------------------------------------
C           mass elimination - supervariable i can be eliminated
C           -------------------------------------------------------
                  PE (I) = -ME
                  NVI = -NV (I)
                  DEGME = DEGME - NVI
                  NVPIV = NVPIV + NVI
                  NEL = NEL + NVI
                  NV (I) = 0
                  ELEN (I) = 0
               ELSE
C           -------------------------------------------------------
C           update the upper-bound degree of i
C           A bound for the new external degree is the old bound plus
C           the size of the generated element
C           -------------------------------------------------------
C
C           the following degree does not yet include the size
C           of the current element, which is added later:
                  DEGREE(I) = MIN (DEG,  DEGREE(I))

C           -------------------------------------------------------
C           add me to the list for i
C           -------------------------------------------------------
C              move first supervariable to end of list
                  IW (PN) = IW (P3)
C              move first element to end of element part of list
                  IW (P3) = IW (P1)
C              add new element to front of list.
                  IW (P1) = ME
C              store the new length of the list in len (i)
                  LEN (I) = PN - P1 + 1

C           -------------------------------------------------------
C           place in hash bucket.  Save hash key of i in last (i).
C           -------------------------------------------------------
                  HASH = ABS(MOD (HASH, HMOD)) + 1
                  J = HEAD (HASH)
                  IF (J .LE. 0) THEN
C                the degree list is empty, hash head is -j
                     DENXT (I) = -J
                     HEAD (HASH) = -I
                  ELSE
C                degree list is not empty - has j as its head
C                last is hash head
                     DENXT (I) = LAST (J)
                     LAST (J) = I
                  ENDIF
                  LAST (I) = HASH
               ENDIF
 183        CONTINUE
         END IF
         DEGREE (ME) = DEGME

C       -------------------------------------------------------------
C       Clear the counter array, w (...), by incrementing wflg.
C       -------------------------------------------------------------
         DMAX = MAX (DMAX, DEGME)
         WFLG = WFLG + DMAX

C        make sure that wflg+n does not cause integer overflow
         IF (WFLG .GE. IOVFLO - N) THEN
            DO 190 X = 1, N
               IF (W (X) .NE. 0) W (X) = 1
 190        CONTINUE
            WFLG = 2
         ENDIF
C        at this point, w (1..n) .lt. wflg holds

C ====================================================================
C  SUPERVARIABLE DETECTION
C ====================================================================
         DO 250 PME = PME1, PME2
            I = IW (PME)
            IF ( (NV(I).GE.0) .OR. (DEGREE(I).GT.N) ) GO TO 250
C           only done for sparse rows
C           replace i by head of its hash bucket, and set the hash
C           bucket header to zero

C           -------------------------------------------------------
C           examine all hash buckets with 2 or more variables.  We
C           do this by examing all unique hash keys for super-
C           variables in the pattern Lme of the current element, me
C           -------------------------------------------------------
            HASH = LAST (I)
C           let i = head of hash bucket, and empty the hash bucket
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
C             degree list is empty
               I = -J
               HEAD (HASH) = 0
            ELSE
C             degree list is not empty, restore last () of head
               I = LAST (J)
               LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250

C           while loop:
            DO 247 JDUMMY = 1,N
               IF (DENXT (I) .EQ. 0) GO TO 250
C             ----------------------------------------------------
C             this bucket has one or more variables following i.
C             scan all of them to see if i can absorb any entries
C             that follow i in hash bucket.  Scatter i into w.
C             ----------------------------------------------------
               LN = LEN (I)
               ELN = ELEN (I)
C              do not flag the first element in the list (me)
               DO 210 P = PE (I) + 1, PE (I) + LN - 1
                  W (IW (P)) = WFLG
 210           CONTINUE

C             ----------------------------------------------------
C             scan every other entry j following i in bucket
C             ----------------------------------------------------
               JLAST = I
               J = DENXT (I)

C             while loop:
               DO 245 IDUMMY=1,N
                  IF (J .EQ. 0) GO TO 246

C               -------------------------------------------------
C               check if j and i have identical nonzero pattern
C               -------------------------------------------------
C               jump if i and j do not have same size data structure
                  IF (LEN (J) .NE. LN) GO TO 240
C               jump if i and j do not have same number adj elts
                  IF (ELEN (J) .NE. ELN) GO TO 240
C               do not flag the first element in the list (me)

                  DO 230 P = PE (J) + 1, PE (J) + LN - 1
C                 jump if an entry (iw(p)) is in j but not in i
                     IF (W (IW (P)) .NE. WFLG) GO TO 240
 230              CONTINUE

C                 -------------------------------------------------
C                 found it!  j can be absorbed into i
C                 -------------------------------------------------
                  PE (J) = -I
C                 both nv (i) and nv (j) are negated since they
C                 are in Lme, and the absolute values of each
C                 are the number of variables in i and j:
                  NV (I) = NV (I) + NV (J)
                  NV (J) = 0
                  ELEN (J) = 0
C                 delete j from hash bucket
                  J = DENXT (J)
                  DENXT (JLAST) = J
                  GO TO 245

C                 -------------------------------------------------
 240              CONTINUE
C               j cannot be absorbed into i
C               -------------------------------------------------
                  JLAST = J
                  J = DENXT (J)
 245           CONTINUE

C             ----------------------------------------------------
C             no more variables can be absorbed into i
C             go to next i in bucket and clear flag array
C             ----------------------------------------------------
 246           WFLG = WFLG + 1
               I = DENXT (I)
               IF (I .EQ. 0) GO TO 250
 247         CONTINUE
 250      CONTINUE

C ====================================================================
C  RESTORE DEGREE LISTS AND REMOVE NONPRINCIPAL SUPERVAR. FROM ELEMENT
C  Squeeze out absorbed variables
C ====================================================================
          P = PME1
          NLEFT = N - NEL
          DO 260 PME = PME1, PME2
             I = IW (PME)
             NVI = -NV (I)
             IF (NVI .LE. 0) GO TO 260
C            i is a principal variable in Lme
C            restore nv (i) to signify that i is principal
             NV (I) = NVI
             IF (DEGREE(I).GT.N) GO TO 258
C           -------------------------------------------------------
C           compute the external degree (add size of current elem)
C           -------------------------------------------------------
             DEG = MIN (DEGREE (I)+ DEGME - NVI, NLEFT - NVI)
             DEGREE (I) = DEG
             IDENSE = .FALSE.
C           -------------------
C           Dense row detection
C           -------------------
             IF (THRESM.GE.0) THEN
C           DEGME is exact external degree of pivot ME |Le\Ve|,
C           DEG is is approx external degree of I
                IF ((DEG+NVI .GE. THRESM).OR.
     &               (DEG+NVI .GE. NLEFT)) THEN
                   IF (THRESM.EQ.N) THEN
C                    We must be sure that I is full in reduced matrix
                      IF ((ELEN(I).LE.2) .AND.((DEG+NVI).EQ.NLEFT)
     &                     .AND. NBD.EQ.NFULL ) THEN
C                        DEG approximation is exact and I is dense
                         DEGREE(I) = N+1
                         IDENSE = .TRUE.
                      ENDIF
                   ELSE
C                     relaxed dense row detection
                      IDENSE = .TRUE.
                      IF ((ELEN(I).LE.2).AND. ((DEG+NVI).EQ.NLEFT)
     &                     .AND. NBD.EQ.NFULL ) THEN
                         DEGREE(I) = N+1
                      ELSE
                         DEGREE(I) = N+1+DEGREE(I)
                      ENDIF
                   ENDIF
                ENDIF
                IF (IDENSE) THEN
C                  update DENXT of all elements in the list of element
C                  adjacent to I (including ME).
                   P1 = PE(I)
                   P2 = P1 + ELEN(I) - 1
                   DO 255 PJ=P1,P2
                      E= IW(PJ)
                      DENXT (E) = DENXT(E) + NVI
 255               CONTINUE
C                  insert I in the list of dense rows
                   NBD = NBD+NVI
                   DEG = N
                   IF (DEGREE(I).EQ.N+1) THEN
c                     insert I at the end of the list
                      NFULL = NFULL +NVI
                      IF (LASTD.EQ.0) THEN
C                        degree list is empty
                         LASTD     = I
                         HEAD(DEG) = I
                         DENXT(I)   = 0
                         LAST(I)   = 0
                      ELSE
C                         IF (NFULL.EQ.NVI) THEN
C                           First full row encountered
                            DENXT(LASTD) = I
                            LAST(I)     = LASTD
                            LASTD       = I
                            DENXT(I)     = 0
C                         ELSE
C                           Absorb I into LASTD (first full row found)
C                            PE(I) = - LASTD
C                            NV(LASTD) = NV(LASTD) + NV(I)
C                            NV(I) = 0
C                            ELEN(I) = 0
C                         END IF
                      ENDIF
                   ELSE
C                     insert I at the beginning of the list
                      INEXT = HEAD(DEG)
                      IF (INEXT .NE. 0) LAST (INEXT) = I
                      DENXT (I) = INEXT
                      HEAD (DEG) = I
                      LAST(I)    = 0
                      IF (LASTD.EQ.0) LASTD=I
                   ENDIF
C               end of IDENSE=true
                ENDIF
C            end of THRESM>0
             ENDIF

             IF (.NOT.IDENSE) THEN
C           -------------------------------------------------------
C           place the supervariable at the head of the degree list
C           -------------------------------------------------------
                INEXT = HEAD (DEG)
                IF (INEXT .NE. 0) LAST (INEXT) = I
                DENXT (I) = INEXT
                LAST (I) = 0
                HEAD (DEG) = I
             ENDIF
C           -------------------------------------------------------
C           save the new degree, and find the minimum degree
C           -------------------------------------------------------
             MINDEG = MIN (MINDEG, DEG)
 258         CONTINUE
C           -------------------------------------------------------
C           place the supervariable in the element pattern
C           -------------------------------------------------------
             IW (P) = I
             P = P + 1
 260      CONTINUE

C =====================================================================
C  FINALIZE THE NEW ELEMENT
C =====================================================================
          OPS = OPS + DEGME*NVPIV + DEGME * NVPIV*NVPIV +
     *         DEGME*DEGME*NVPIV + NVPIV*NVPIV*NVPIV/3 +
     *         NVPIV*NVPIV/2 + NVPIV/6 + NVPIV
          NRLADU = NRLADU + (NVPIV*(NVPIV+1))/2 + (DEGME*NVPIV)
          NV (ME) = NVPIV + DEGME
C         nv (me) is now the degree of pivot (including diagonal part)
C         save the length of the list for the new element me
          LEN (ME) = P - PME1
          IF (LEN (ME) .EQ. 0) THEN
C            there is nothing left of the current pivot element
             PE (ME) = 0
             W (ME) = 0
          ENDIF
          IF (NEWMEM .NE. 0) THEN
C            element was not constructed in place: deallocate part
C            of it (final size is less than or equal to newmem,
C            since newly nonprincipal variables have been removed).
             PFREE = P
             MEM = MEM - NEWMEM + LEN (ME)
          ENDIF

C =====================================================================
C       END WHILE (selecting pivots)
          GO TO 30
       ENDIF
C =====================================================================
       GO TO 265

C      We have only full rows that we amalgamate at the root
C      node and ME = LASTD
C      Perform mass elimination of all full rows
 263   NELME    = -(NEL+1)
       DO 264 X=1,N
          IF ((PE(X).GT.0) .AND. (ELEN(X).LT.0)) THEN
C            X is an unabsorbed element
             PE(X) = -ME
          ELSEIF (DEGREE(X).EQ.N+1) THEN
C            X is a dense row, absorb it in ME (mass elimination)
             NEL   = NEL + NV(X)
             PE(X) = -ME
             ELEN(X) = 0
             NV(X) = 0
          ENDIF
 264   CONTINUE
C      ME is the root node
       ELEN(ME) = NELME
       NV(ME)   = NBD
       NRLADU = NRLADU + (NBD*(NBD+1))/2
       OPS = OPS + NBD*NBD*NBD/3 + NBD*NBD/2 + NBD/6 + NBD
       PE(ME)   = 0

 265   CONTINUE
C ===================================================================
C  COMPUTE THE PERMUTATION VECTORS
C ===================================================================

C     ----------------------------------------------------------------
C     The time taken by the following code is O(n).  At this
C     point, elen (e) = -k has been done for all elements e,
C     and elen (i) = 0 has been done for all nonprincipal
C     variables i.  At this point, there are no principal
C     supervariables left, and all elements are absorbed.
C     ----------------------------------------------------------------
C
C     ----------------------------------------------------------------
C     compute the ordering of unordered nonprincipal variables
C     ----------------------------------------------------------------

       DO 290 I = 1, N
          IF (ELEN (I) .EQ. 0) THEN
C         ----------------------------------------------------------
C         i is an un-ordered row.  Traverse the tree from i until
C         reaching an element, e.  The element, e, was the
C         principal supervariable of i and all nodes in the path
C         from i to when e was selected as pivot.
C         ----------------------------------------------------------
             J = -PE (I)
C         while (j is a variable) do:
             DO 270 JDUMMY = 1,N
                IF (ELEN (J) .LT. 0) GO TO 275
                J = -PE (J)
 270         CONTINUE
 275         E = J
C           ----------------------------------------------------------
C           get the current pivot ordering of e
C           ----------------------------------------------------------
             K = -ELEN (E)

C           ----------------------------------------------------------
C           traverse the path again from i to e, and compress the
C           path (all nodes point to e).  Path compression allows
C           this code to compute in O(n) time.  Order the unordered
C           nodes in the path, and place the element e at the end.
C           ----------------------------------------------------------
             J = I
C            while (j is a variable) do:
             DO 280 IDUMMY = 1,N
                IF (ELEN (J) .LT. 0) GO TO 285
                JNEXT = -PE (J)
                PE (J) = -E
                IF (ELEN (J) .EQ. 0) THEN
C                  j is an unordered row
                   ELEN (J) = K
                   K = K + 1
                ENDIF
                J = JNEXT
 280         CONTINUE
C            leave elen (e) negative, so we know it is an element
 285         ELEN (E) = -K
          ENDIF
 290   CONTINUE

C     ----------------------------------------------------------------
C     reset the inverse permutation (elen (1..n)) to be positive,
C     and compute the permutation (last (1..n)).
C     ----------------------------------------------------------------
       DO 300 I = 1, N
          K = ABS (ELEN (I))
          LAST (K) = I
          ELEN (I) = K
 300   CONTINUE

C ====================================================================
C  RETURN THE MEMORY USAGE IN IW AND SET INFORMATION ARRAYS
C ====================================================================
C     If maxmem is less than or equal to iwlen, then no compressions
C     occurred, and iw (maxmem+1 ... iwlen) was unused.  Otherwise
C     compressions did occur, and iwlen would have had to have been
C     greater than or equal to maxmem for no compressions to occur.
C     Return the value of maxmem in the pfree argument.

       RJNFO(1) = OPS
       RJNFO(2) = NRLADU
       JNFO(1) = NCMPA
       JNFO(2) = RSTRT
       PFREE = MAXMEM

       RETURN
       END
